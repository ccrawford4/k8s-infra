name: Deploy Helm Charts

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
    secrets:
      AWS_ACCOUNT:
        required: true
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      AWS_EKS_CLUSTER_NAME:
        required: true
      MYSQL_DATABASE:
        required: true
      MYSQL_USERNAME:
        required: true
      MYSQL_PASSWORD:
        required: true
      MYSQL_ROOT_PASSWORD:
        required: true
      GH_CLIENT_ID:
        required: true
      GH_SECRET:
        required: true
      NEXTAUTH_SECRET:
        required: true
      GOOGLE_ID:
        required: true
      GOOGLE_SECRET:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@master
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ secrets.AWS_REGION }} \
            --name ${{ secrets.AWS_EKS_CLUSTER_NAME }} \
            --kubeconfig ./kubeconfig.yaml

      - name: Create environment namespace if not exists
        env:
          KUBECONFIG: ./kubeconfig.yaml
        run: |
          kubectl get namespace ${{ inputs.environment }} || kubectl create namespace ${{ inputs.environment }}

      - name: Create argocd namespace if not exists
        env:
          KUBECONFIG: ./kubeconfig.yaml
        run: |
          kubectl get namespace argocd || kubectl create namespace argocd

      - name: Deploy ArgoCD
        env:
          KUBECONFIG: ./kubeconfig.yaml
        run: |
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Set charts to deploy
        id: set-charts
        run: |
          if [ ${{ inputs.environment }} == "qa" ]; then
            echo "charts=searchapi mysql web redis" >> $GITHUB_ENV
          else
            echo "charts=searchapi web redis" >> $GITHUB_ENV
          fi

      - name: Deploy mysql chart
        if: contains(env.charts, 'mysql')
        uses: vimeda/helm@v1.7.0
        with:
          release: mysql
          namespace: ${{ inputs.environment }}
          chart: ./charts/mysql
          values: |
            database: ${{ secrets.MYSQL_DATABASE }}
            username: ${{ secrets.MYSQL_USERNAME }}
            password: ${{ secrets.MYSQL_PASSWORD }}
            root_password: ${{ secrets.MYSQL_ROOT_PASSWORD }}
        env:
          KUBECONFIG: ./kubeconfig.yaml

      - name: Deploy redis chart
        if: contains(env.charts, 'redis')
        uses: vimeda/helm@v1.7.0
        with:
          release: redis
          namespace: ${{ inputs.environment }}
          chart: ./charts/redis
          values: |
            password: ${{ secrets.REDIS_PASSWORD }}
        env:
          KUBECONFIG: ./kubeconfig.yaml

      - name: Deploy searchapi chart
        if: contains(env.charts, 'searchapi')
        uses: vimeda/helm@v1.7.0
        with:
          release: searchapi
          namespace: ${{ inputs.environment }}
          chart: ./charts/searchapi
          values: |
            containerPort: 8080
            DSN: "root:${{ secrets.MYSQL_ROOT_PASSWORD }}@tcp(mysql.${{ inputs.environment }}.svc.cluster.local:3306)/${{ secrets.MYSQL_DATABASE }}?charset=utf8mb4&parseTime=true&loc=Local"
            REDIS_HOST: "redis.${{ inputs.environment }}.svc.cluster.local:6379"
            REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
        env:
          KUBECONFIG: ./kubeconfig.yaml

      - name: Extract searchapi LoadBalancer endpoint
        if: contains(env.charts, 'searchapi')
        run: |
          # Wait for LoadBalancer to get external IP
          until kubectl get svc searchapi -n qa -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' | grep -q .; do
            echo "Waiting for searchapi LoadBalancer to get external IP..."
            sleep 10
          done

          # Store the external IP/domain
          SEARCHAPI_EXTERNAL_IP=$(kubectl get svc searchapi -n ${{ inputs.environment }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          # If using hostname instead of IP (for AWS, Azure)
          if [ -z "$SEARCHAPI_EXTERNAL_IP" ]; then
            SEARCHAPI_EXTERNAL_IP=$(kubectl get svc searchapi -n ${{ inputs.environment }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          fi

          echo "SEARCHAPI_LB_ENDPOINT=$SEARCHAPI_EXTERNAL_IP" >> $GITHUB_ENV
          echo "Searchapi LoadBalancer endpoint: $SEARCHAPI_EXTERNAL_IP"
        env:
          KUBECONFIG: ./kubeconfig.yaml

      - name: Deploy web chart
        if: contains(env.charts, 'web')
        uses: vimeda/helm@v1.7.0
        with:
          release: web
          namespace: ${{ inputs.environment }}
          chart: ./charts/web
          values: |
            API_ENDPOINT: http://<searchapi service load balancer>search
            NEXTAUTH_URL: http://<web service load balancer>/api/auth
            GITHUB_CLIENT_ID: ${{ secrets.GH_CLIENT_ID }}
            GITHUB_SECRET: ${{ secrets.GH_SECRET }}
            NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
            GOOGLE_ID: ${{ secrets.GOOGLE_ID }}
            GOOGLE_SECRET: ${{ secrets.GOOGLE_SECRET }}
        env:
          KUBECONFIG: ./kubeconfig.yaml

      - name: Update web with LoadBalancer endpoint
        if: contains(env.charts, 'web')
        run: |
          # Get web LoadBalancer address
          WEB_LB=$(get_lb_address "web" "${{ inputs.environment }}")
          echo "WEB_LB_ENDPOINT=$WEB_LB" >> $GITHUB_ENV
          echo "Web LoadBalancer endpoint: $WEB_LB"

          # Get current values from the release
          helm get values web -n ${{ inputs.environment }} > web-values.yaml

          # Update the web deployment with NEXTAUTH_URL
          helm upgrade web ./charts/web \
            --namespace ${{ inputs.environment }} \
            -f web-values.yaml \
            --set NEXTAUTH_URL=http://$WEB_LB/api/auth \
            --reuse-values
        env:
          KUBECONFIG: ./kubeconfig.yaml
